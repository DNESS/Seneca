#!/usr/bin/python

INFO = '''
Version:  1.4
Date:     23/01/2013 (dd/mm/yyyy)
Name:     Jon Chiappetta (jonc_mailbox@yahoo.ca)
'''.strip()

import getopt
import os
import random
import re
import shutil
import subprocess
import sys
import time

ARMS = {"general":"generic", "guru":"kirkwood", "panda":"omap", "any":"vexpress"}

# Implement "mkdir -p" in python

def mdir(root, subs, pref=""):
	subl = subs.split("/")
	outp = ""
	
	if (pref):
		pref += "-"
	
	for subi in subl:
		if (not subi):
			continue
		
		fold = ("%s/%s" % (root, subi))
		
		if (outp):
			outp += " && "
		
		outp += fold
		
		try:
			os.unlink(fold)
		except:
			pass
		
		try:
			os.mkdir(fold)
		except:
			pass
		
		root = fold
	
	print("%sMkdir :: [%s]" % (pref, outp))

'''
	Mount the main disk image file (kpartx) using loopback devices
'''

def disk(opts, mode):
	if (mode == "a"):
		# Mount the main disk image
		
		pipe = subprocess.Popen(["/sbin/kpartx", "-av", opts["disk"][2]], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		outp = pipe.stdout.readlines()
		pipe.stdout.close()
		
		return outp
	
	if (mode == "d"):
		# Sync the filesystems
		
		subprocess.call(["/bin/sync"])
		
		# Unmount all of the partitions
		
		for keyn in opts:
			if ((keyn != "boot") and (keyn != "root")):
				continue
			
			trys = 0
			
			while (1):
				retn = subprocess.call(["/bin/umount", opts[keyn][1]])
				
				if ((trys >= 3) or (retn == 0)):
					break
				
				trys += 1
				time.sleep(1)
		
		# Unmount the main disk image
		
		trys = 0
		
		while (1):
			retn = subprocess.call(["/sbin/kpartx", "-d", opts["disk"][2]])
			
			if ((trys >= 3) or (retn == 0)):
				break
			
			trys += 1
			time.sleep(1)
	
	return []

'''
	Mount the needed partitions (boot & root) within the main disk image (/mnt)
'''

def mnts(opts, devs):
	# Loop thru the disk mount output and check for the needed loopback device files
	
	leng = len(devs)
	
	for x in range(0, leng):
		item = devs[x].strip().replace("\t", " ")
		item = re.sub(" [ ]*", " ", item)
		
		devl = item.split(" ")
		
		if (len(devl) < 3):
			continue
		
		if (not re.match("^loop[0-9]+p[0-9]+$", devl[2])):
			continue
		
		numb = int(re.sub("^loop[0-9]+p", "", devl[2]))
		
		for keyn in opts:
			if (opts[keyn][0] == -1):
				opts[keyn][0] = leng
			if (opts[keyn][0] == numb):
				opts[keyn][2] = ("/dev/mapper/%s" % (devl[2]))
	
	if ((not opts["boot"][2]) or (not opts["root"][2])):
		print("Error in finding the [%s]->[%s] / [%s]->[%s] devices!" % (opts["boot"][1], opts["boot"][2], opts["root"][1], opts["root"][2]))
		sys.exit(1)
	
	# Attempt to mount the needed partitions
	
	for keyn in opts:
		if ((keyn != "boot") and (keyn != "root")):
			continue
		
		pipe = subprocess.Popen(["/bin/umount", opts[keyn][1]], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		pipe.stdout.close()
		
		mdir("", opts[keyn][1])
		
		print("Mount :: [%s] -> [%s]" % (opts[keyn][2], opts[keyn][1]))
		
		retn = subprocess.call(["/bin/mount", opts[keyn][2], opts[keyn][1]])
		
		if (retn != 0):
			print("Error mounting the [%s] partition!" % (keyn))
			disk(opts, "d")
			sys.exit(1)
	
	return opts

'''
	Move the current boot partition files to the root filesystem boot folder
'''

def move(opts):
	global ARMS
	
	if ((opts["type"][2] == ARMS["guru"]) or (opts["type"][2] == ARMS["panda"])):
		mdir(opts["root"][1], "/boot/uboot")
		
		for item in os.listdir(opts["boot"][1]):
			srcf = ("%s/%s" % (opts["boot"][1], item))
			dstf = ("%s/boot/%s" % (opts["root"][1], item))
			
			print("Move :: [%s] -> [%s]" % (srcf, dstf))
			
			try:
				shutil.copyfile(srcf, dstf)
			except:
				try:
					shutil.copytree(srcf, dstf, symlinks=True)
				except:
					print("Warning during copy [%s] !-> [%s]" % (srcf, dstf))

'''
	Unmount and format the boot partition to start clean
'''

def form(opts):
	global ARMS
	
	if ((opts["type"][2] == ARMS["guru"]) or (opts["type"][2] == ARMS["panda"])):
		# Umount the mounted partitioned
		
		retn = subprocess.call(["/bin/umount", opts["boot"][1]])
		
		if (retn != 0):
			print("Error unmounting the [%s] partition!" % ("boot"))
			disk(opts, "d")
			sys.exit(1)
		
		# Modify the partition type
		
		pipe = subprocess.Popen(["/sbin/sfdisk", "-d", opts["disk"][2]], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		outp = pipe.stdout.readlines()
		pipe.stdout.close()
		
		flag = 0
		fobj = open("/tmp/tmp.lmm.tmp.txt", "w")
		for x in range(0, len(outp)):
			if ((flag == 0) and re.match("^.*,[ ]+Id=[0-9A-Fa-f ]+.*$", outp[x].strip(), re.I)):
				outp[x] = (re.sub(",[ ]+Id=[0-9A-Fa-f ]+", ", Id= c", outp[x].strip()) + "\n")
				print("Fdisk :: [%s] %s" % (opts["disk"][2], outp[x].strip()))
				flag = 1
			fobj.write(outp[x])
		fobj.close()
		
		fobj = open("/tmp/tmp.lmm.tmp.txt", "r")
		pipe = subprocess.Popen(["/sbin/sfdisk", opts["disk"][2]], stdin=fobj, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		fobj.close()
		pipe.communicate()
		pipe.stdout.close()
		
		# Format the partition
		
		print("Mkfs :: %s" % (opts["boot"][2]))
		
		retn = subprocess.call(["/sbin/mkfs.vfat", "-F", "32", "-n", "uboot", opts["boot"][2]])
		
		if (retn != 0):
			print("Error making filesystem on [%s]!" % (opts["boot"][2]))
			disk(opts, "d")
			sys.exit(1)

'''
	Copy over the needed boot files for this device type (sync the MLO first)
'''

def boot(opts):
	global ARMS
	
	if ((opts["type"][2] == ARMS["guru"]) or (opts["type"][2] == ARMS["panda"])):
		fles = []
		
		# Get a list of uboot files from the root partition
		
		dirp = ("%s/usr/share" % (opts["root"][1]))
		dirl = os.listdir(dirp)
		
		for item in dirl:
			diri = ("%s/%s" % (dirp, item))
			
			if (not os.path.isdir(diri)):
				continue
			
			if (re.match("^uboot-.*$", item, re.I)):
				flst = os.listdir(diri)
				
				for fili in flst:
					filn = ("%s/%s" % (diri, fili))
					
					if (os.path.isfile(filn)):
						fles.append(filn)
		
		# Get a list of boot files from the root partition
		
		dirp = ("%s/boot" % (opts["root"][1]))
		dirl = os.listdir(dirp)
		
		for item in dirl:
			if (re.match("^(boot\.|uImage|uInitrd|uEnv|klist\.).*$", item)):
				filn = ("%s/%s" % (dirp, item))
				
				if (os.path.isfile(filn)):
					fles.append(filn)
		
		# Re-mount the boot partition since last format
		
		retn = subprocess.call(["/bin/mount", opts["boot"][2], opts["boot"][1]])
		
		if (retn != 0):
			print("Error mounting the [%s] partition before MLO write!" % ("boot"))
			disk(opts, "d")
			sys.exit(1)
		
		# Copy over the MLO first specifically, sync the files, unmount and re-mount the partition
		
		for item in fles:
			srcf = item.strip()
			name = os.path.basename(srcf)
			
			if (not os.path.isfile(srcf)):
				continue
			
			if (name.lower() == "mlo"):
				dstf = ("%s/%s" % (opts["boot"][1], name))
				
				print("Copy :: [%s] -> [%s]" % (srcf, dstf))
				
				try:
					shutil.copyfile(srcf, dstf)
				except:
					print("Warning during copy [%s] !-> [%s]" % (srcf, dstf))
		
		print("Sync :: [%s]" % (opts["boot"][2]))
		
		retn = subprocess.call(["/bin/sync"])
		
		if (retn != 0):
			print("Error during disk sync!")
			disk(opts, "d")
			sys.exit(1)
		
		retn = subprocess.call(["/bin/umount", opts["boot"][1]])
		
		if (retn != 0):
			print("Error unmounting the [%s] partition after MLO write!" % ("boot"))
			disk(opts, "d")
			sys.exit(1)
		
		retn = subprocess.call(["/bin/mount", opts["boot"][2], opts["boot"][1]])
		
		if (retn != 0):
			print("Error mounting the [%s] partition before uboot write!" % ("boot"))
			disk(opts, "d")
			sys.exit(1)
		
		# Copy over the rest of the boot files now except the MLO
		
		for item in fles:
			srcf = item.strip()
			name = os.path.basename(srcf)
			
			if (not os.path.isfile(srcf)):
				continue
			
			if (name.lower() != "mlo"):
				dstf = ("%s/%s" % (opts["boot"][1], name))
				
				print("Copy :: [%s] -> [%s]" % (srcf, dstf))
				
				try:
					shutil.copyfile(srcf, dstf)
				except:
					print("Warning during copy [%s] !-> [%s]" % (srcf, dstf))

'''
	Remove, modify, or create any needed config or binary files
'''

def conf(opts):
	global ARMS
	
	fold = "."
	name = os.path.basename(opts["disk"][2]).replace(".img", "")
	
	if (opts["type"][2] == ARMS["general"]):
		name += "-rootfs"
	
	dirp = ("%s/%s" % (fold, name))
	
	if ((opts["type"][2] == ARMS["guru"]) or (opts["type"][2] == ARMS["panda"])):
		# Fix the fstab file with the new partition UUID
		
		uuid = ""
		
		pipe = subprocess.Popen(["/sbin/blkid", opts["boot"][2]], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		outp = pipe.stdout.readlines()
		pipe.stdout.close()
		
		for item in outp:
			item = item.strip()
			regx = re.match("^.*UUID=.([0-9A-Za-z-]+)..*$", item, re.I)
			
			if (regx):
				uuid = regx.group(1)
		
		if (not uuid):
			print("Could not find a new uuid for [%s]!" % ("boot"))
			disk(opts, "d")
			sys.exit(1)
		
		filn = ("%s/etc/fstab" % (opts["root"][1]))
		
		try:
			filo = open(filn, "r")
			fill = filo.readlines()
			filo.close()
		except:
			print("Could not read [%s] file!" % (filn))
			disk(opts, "d")
			sys.exit(1)
		
		try:
			filo = open(filn, "w")
			
			for fili in fill:
				if (re.match("^.* /boot[/ ].*$", fili, re.I)):
					fili = ("UUID=%s        /boot/uboot        vfat        defaults,noauto        1 2\n" % (uuid))
					print("Write :: [%s] <- [%s]" % (filn, uuid))
				filo.write(fili)
			
			filo.close()
		
		except:
			print("Could not write to file [%s]!" % (filn))
			disk(opts, "d")
			sys.exit(1)
		
		# Fix the sysconfig uboot file with a new path to the uboot directory
		
		try:
			filn = ("%s/etc/sysconfig/uboot" % (opts["root"][1]))
			filo = open(filn, "a")
			filo.write("UBOOT_DIR=/boot/uboot\n")
			filo.write("UBOOT_DEVICE=mmcblk0p%d\n" % (opts["boot"][0]))
			filo.close()
			print("Write :: [%s]" % (filn))
		except:
			print("Error appending to the sysconfig uboot file!")
			disk(opts, "d")
			sys.exit(1)
	
	if (opts["type"][2] == ARMS["any"]):
		# Define the main vexpress boot script
		
		data = '''#!/bin/sh

KERN="$1"
RAMFS="$2"
IMAGE="$3"

if [ X$RAMFS = X ]; then
  echo "Usage: $0 kernel initramfs image"
  exit 1
fi

if [ ! -f "$KERN" ]; then
  echo "$KERN not found"
  exit 1
fi
if [ ! -f "$RAMFS" ]; then
  echo "$RAMFS not found"
  exit 1
fi
if [ ! -f "$IMAGE" ]; then
  echo "$IMAGE not found"
  exit 1
fi

if [ -f /usr/bin/qemu-system-arm ]; then
  %s \\
    %s \\
    -kernel "$KERN" \\
    -initrd "$RAMFS" \\
    -sd "$IMAGE"
else
  echo "You need to install qemu-system-arm to boot a versatile express image"
fi'''
		
		dlst = [	["","qemu-system-arm -machine vexpress-a9 -m 1024 -nographic -net nic -net user","-append \"console=ttyAMA0,115200n8 rw root=/dev/mmcblk0p%d rootwait physmap.enabled=0\"" % (opts["root"][0])],
					["+x","qemu-system-arm -machine vexpress-a9 -m 1024 -net nic -net user","-append \"rw root=/dev/mmcblk0p%d rootwait physmap.enabled=0\"" % (opts["root"][0])]
		]
		
		mdir(fold, "%s/boot" % (name), pref=opts["type"][2])
		
		# Copy out common boot files for the archive
		
		for srcp in ["%s" % (opts["boot"][1]), "%s/boot" % (opts["root"][1])]:
			try:
				flst = os.listdir(srcp)
			except:
				flst = []
			
			for fitm in flst:
				for regx in ["initramfs-.*", "vmlinuz-.*"]:
					if (re.match("^%s$" % (regx), fitm, re.I)):
						srcf = ("%s/%s" % (srcp, fitm))
						dstf = ("%s/boot/%s" % (dirp, fitm))
						
						print("%s-Copy :: [%s] -> [%s]" % (opts["type"][2], srcf, dstf))
						
						try:
							shutil.copyfile(srcf, dstf)
						except:
							print("Warning during copy [%s] !-> [%s]" % (srcf, dstf))
		
		# Create the needed vexpress shell scripts
		
		for item in dlst:
			dstf = ("%s/boot/boot-vexpress%s" % (dirp, item[0]))
			
			print("%s-Write :: [%s]" % (opts["type"][2], dstf))
			
			try:
				fobj = open(dstf, "w")
				fobj.write(data % (item[1], item[2]))
				fobj.close()
			except:
				print("Error writing to file [%s]!" % (dstf))
				disk(opts, "d")
				sys.exit(1)
			
			print("%s-Chmod :: [%s]" % (opts["type"][2], dstf))
			
			retn = subprocess.call(["/bin/chmod", "755", dstf])
			
			if (retn != 0):
				print("Error changing permissions on file [%s]!" % (dstf))
				disk(opts, "d")
				sys.exit(1)
	
	if (opts["type"][2] == ARMS["general"]):
		if (opts["cmpr"][2] == "true"):
			# Create a consolidated root fs archive
			
			tarb = ("%s.tar.xz" % (name))
			
			fold = opts["root"][1]
			name = ""
			
			print("%s-Tar :: [%s] <- (-> [%s/]) [./%s]" % (opts["type"][2], tarb, fold, name))
			
			retn = subprocess.call(["/bin/tar", "-cJf", tarb, "-C", "%s/" % (fold), "--exclude=./boot/*", "--exclude=./lib/modules/*", "--exclude=./usr/lib/modules/*", "./%s" % (name)])
			
			if (retn != 0):
				print("Error creating tarball file [%s]!" % (tarb))
				disk(opts, "d")
				sys.exit(1)

'''
	Perform any final configurations
'''

def last(opts):
	global ARMS
	
	fold = "."
	name = os.path.basename(opts["disk"][2]).replace(".img", "")
	
	if (opts["type"][2] == ARMS["general"]):
		name += "-rootfs"
	
	dirp = ("%s/%s" % (fold, name))
	
	if (opts["type"][2] == ARMS["any"]):
		# Copy over the main disk image file
		
		mdir(fold, name, pref=opts["type"][2])
		
		srcf = opts["disk"][2]
		dstf = ("%s/%s" % (dirp, os.path.basename(srcf)))
		
		print("%s-Copy :: [%s] -> [%s]" % (opts["type"][2], srcf, dstf))
		
		try:
			shutil.copyfile(srcf, dstf)
		except:
			print("Warning during copy [%s] !-> [%s]" % (srcf, dstf))
		
		if (opts["cmpr"][2] == "true"):
			# Create a consolidated file archive and remove the folder
			
			mdir(fold, name, pref=opts["type"][2])
			tarb = ("%s.tar.xz" % (name))
			
			print("%s-Tar :: [%s] <- (-> [%s/]) [./%s]" % (opts["type"][2], tarb, fold, name))
			
			retn = subprocess.call(["/bin/tar", "-cJf", tarb, "-C", "%s/" % (fold), "./%s" % (name)])
			
			if (retn != 0):
				print("Error creating tarball file [%s]!" % (tarb))
				sys.exit(1)
			
			print("%s-Remove :: [%s]" % (opts["type"][2], dirp))
			
			try:
				shutil.rmtree(dirp)
			except:
				pass

'''
	Main method called during program execution
'''

def main():
	global INFO
	global ARMS
	
	# Define the main method variables
	
	comd = os.path.basename(sys.argv[0])
	spce = (" " * len(comd))
	
	usem = ('''
%s [-h, --help] [-v, --version]
%s --image=IMAGE_NAME
%s --platform=PLATFORM
%s --nocompress
''' % (comd, spce, spce, spce)).strip()
	
	help = '''
Modify a livemedia-creator image for specific platform requirements.
  -h, --help            Show this help message and exit.
  -v, --version         Display the current version number and last modification date.
  --image=IMAGE_NAME    Name of disk image to modify.
  --platform=PLATFORM   Platform to target {generic,kirkwood,omap,vexpress}.
  --nocompress          Modify the image without any final archival or compression (for vexpress).
'''.strip()
	
	if (os.getuid() != 0):
		print("Please run this script as the root user!")
		sys.exit(1)
	
	try:
		(opts, args) = getopt.getopt(sys.argv[1:], "hv", ["image=", "platform=", "nocompress", "help", "version"])
	except:
		print(usem)
		sys.exit(1)
	
	# options = { name : [ index , location , value ] , ... }
	
	optl = {	"disk":[-2, "/dev/null", None], "boot":[1, "/mnt/boot", None], "root":[-1, "/mnt/root", None],
				"type":[-2, "/dev/null", None], "cmpr":[-2, "/dev/null", "true"]
	}
	
	# Parse thru the command line arguments and options
	
	for opti in opts:
		if (opti[0] == "--image"):
			optl["disk"][2] = opti[1]
		if (opti[0] == "--platform"):
			optl["type"][2] = opti[1]
		if ((opti[0] == "-h") or (opti[0] == "--help")):
			print(usem + "\n\n" + help)
			sys.exit(1)
		if ((opti[0] == "-v") or (opti[0] == "--version")):
			print(INFO)
			sys.exit(1)
	
	if ((not optl["disk"][2]) or (not os.path.exists(optl["disk"][2]))):
		print("Could not find the image file [%s]!" % (optl["disk"][2]))
		sys.exit(1)
	
	found = 0
	
	for ARMI in ARMS.keys():
		if (ARMS[ARMI] == optl["type"][2]):
			found = 1
	
	if (found == 0):
		print("Could not recognize the platform type [%s]!" % (optl["type"][2]))
		sys.exit(1)
	
	for opti in opts:
		if (opti[0] == "--nocompress"):
			optl["cmpr"][2] = None
	
	if ((optl["type"][2] != ARMS["any"]) and (optl["type"][2] != ARMS["general"])):
		optl["cmpr"][2] = None
	
	# Call all of the sub methods
	
	loop = disk(optl, "a")
	optl = mnts(optl, loop)
	
	try:
		move(optl)
		form(optl)
		boot(optl)
		conf(optl)
	
	finally:
		disk(optl, "d")
		last(optl)
	
	print("\nModification completed successfully!")

if (__name__ == "__main__"):
	main()
